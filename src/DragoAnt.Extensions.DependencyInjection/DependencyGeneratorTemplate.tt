<#@ template language="C#" linePragmas="false" inherits="BaseTransformation<ResolveDependenciesData>" visibility="internal" #>
<#@ import namespace="System.Collections.Immutable" #>
<#@ import namespace="DragoAnt.Extensions.DependencyInjection.Templates" #>
// This file generated by DragoAnt.Extensions.DependencyInjection source generator

<#
    if (Data is { CustomDependenciesEnabled: false, AlwaysGenerateAddDependenciesMethod: false, Errors.Length: 0, Dependencies.Length: 0, Factories.Length: 0 })
    {
#>
// No Resolve or/and ResolveFactory marked class/interface found. 
<#
    }
    else if (Data.Errors.Length != 0)
    {
        foreach (var error in Data.Errors)
        {
#>
#error <#= error #>
<#
        }
    }
    else
    {
#>

#nullable enable

<#
        foreach (var usingNs in Data
            .GetUsings("Microsoft.Extensions.DependencyInjection")
            .Except([Data.Namespace]))
        {
#>
using <#= usingNs #>;
<#
        }
#>

[assembly:ResolveAssembly("<#= Data.Namespace #>.<#= Data.ExtensionsClassName #>.<#= Data.MethodCodeName #>")]

namespace <#= Data.Namespace #>;

/// <summary>
/// Dependency injection registration extensions.
/// </summary>
public static partial class <#= Data.ExtensionsClassName #>
{
    /// <summary>
    /// <#= Data.MethodCodeName #> dependencies and factories registration extension.
    /// </summary>
    /// <remarks>Generated by <a href="https://github.com/DragoAnt/Extensions.DependencyInjection">DragoAnt.Extensions.DependencyInjection</a> source generator.</remarks>
    public static void <#= Data.MethodCodeName #>(this IServiceCollection services)
    {
<#
        foreach (var dependency in Data.Dependencies.OrderBy(v => v.InstanceClassName))
        {
            var addService = $"services.Add{dependency.Lifetime}";
#>
        <#= addService #><<#= dependency.InstanceClassName #>>();
<#
            foreach (var iface in dependency.Interfaces)
            {
#>
        <#= addService #><<#= iface #>>(p => p.GetRequiredService<<#= dependency.InstanceClassName #>>());
<#
            }
        }

        foreach (var factory in Data.Factories.OrderBy(v => v.FactoryClassName))
        {
            var addService = $"services.Add{factory.Lifetime}";
            var interfaces = factory.GetInterfaces().ToImmutableArray();
            if (interfaces.Length > 1)
            {
#>
        <#= addService #><<#= factory.FactoryClassName #>>();
<#
                foreach (var iface in interfaces)
                {
#>
        <#= addService #><<#= iface.Name #>>(p => p.GetRequiredService<<#= factory.FactoryClassName #>>());
<#
                }
            }
            else
            {
#>
        <#= addService #><<#= interfaces[0].Name #>, <#= factory.FactoryClassName #>>();
<#
            }
        }

        if (Data.CustomDependenciesEnabled)
        {
#>

        AddCustomDependencies(services);
<#
        }
#>
    }
<#
        if (Data.CustomDependenciesEnabled)
        {
#>
    /// <summary>
    /// Custom dependencies registration
    /// </summary>
    private static partial void AddCustomDependencies(IServiceCollection services);
<#
        }
#>

}
<#
        foreach (var factory in Data.Factories.OrderBy(v => v.FactoryClassName))
        {
            if (factory.GeneratingInterface is {} generatingInterface)
            {
#>

/// <summary>
/// Factory contract for <see cref="<#= factory.InstanceClassName #>"/>.
/// </summary>
public interface <#= generatingInterface.Name #>
{
<#
                foreach (var method in generatingInterface.Methods)
                {
#>
    <#= factory.InstanceClassName #> Create(<#= method.GetParametersForSignature(true) #>);
<#
                }
#>
}
<#
            }
#>

/// <summary>
/// Factory implementation for <see cref="<#= factory.InstanceClassName #>"/>.
/// </summary>
internal sealed class <#= factory.FactoryClassName #> : <#= string.Join(", ", factory.GetInterfaces().Select(i => i.Name)) #>
{
    private readonly IServiceProvider _provider;

    public <#= factory.FactoryClassName #>(IServiceProvider provider)
    {
        _provider = provider;        
    }

<#
            foreach (var iface in factory.GetInterfaces())
            {
                foreach (var method in iface.Methods)
                {
#>
    <#= method.ReturnTypeName #> <#= iface.Name #>.<#= method.Name #>(<#= method.GetParametersForSignature(false) #>) =>
<#
                    var ctor = method.GetEquivalentConstructorMethod(factory.Constructors, iface.CastParameters);
                    if (ctor is null || ctor.Value.IsEmpty)
                    {
                        if (iface.AllowNotSupportedMethods)
                        {
#>
        throw new System.NotSupportedException();
<#
                        }
                        else
                        {
#>
#error ResolveFactory: Can't find equivalent construtor for interface's method.
<#
                        }
                        continue;
                    }
#>
        new <#= factory.InstanceClassName #>(<#= ctor.Value.GetCallCtorParameters("_provider", method) #>);
<#
                }
            }
#>
}
<#
        }
    }
#>