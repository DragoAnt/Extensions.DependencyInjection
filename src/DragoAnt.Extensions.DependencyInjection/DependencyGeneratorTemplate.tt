<#@ template language="C#" linePragmas="false" inherits="BaseTransformation<ResolveDependenciesData>" visibility="internal" #>
<#@ import namespace="DragoAnt.Extensions.DependencyInjection.Templates" #>
// This file generated by DragoAnt.Extensions.DependencyInjection source generator.
// More details: https://github.com/DragoAnt/Extensions.DependencyInjection


<#
    if (Data is { CustomDependenciesEnabled: false, AlwaysGenerateAddDependenciesMethod: false, Errors.Length: 0, Dependencies.Length: 0, Factories.Length: 0 })
    {
#>
// No Resolve or/and ResolveFactory marked class/interface found. 
<#
    }
    else if (Data.Errors.Length != 0)
    {
        foreach (var error in Data.Errors)
        {
#>
#error <#= error #>
<#
        }
    }
    else
    {
#>

#nullable enable

<#
        foreach (var usingNs in Data
            .GetUsings("Microsoft.Extensions.DependencyInjection")
            .Except([Data.Namespace]))
        {
#>
using <#= usingNs #>;
<#
        }
#>
using static Microsoft.Extensions.DependencyInjection.ServiceLifetime;

[assembly:ResolveAssembly("<#= Data.Namespace #>.<#= Data.ExtensionsClassName #>.<#= Data.MethodCodeName #>")]

namespace <#= Data.Namespace #>;

/// <summary>
/// Dependency injection registration extensions.
/// </summary>
public static partial class <#= Data.ExtensionsClassName #>
{
    /// <summary>
    /// <#= Data.MethodCodeName #> dependencies and factories registration extension.
    /// </summary>
    /// <remarks>Generated by <a href="https://github.com/DragoAnt/Extensions.DependencyInjection">DragoAnt.Extensions.DependencyInjection</a> source generator.</remarks>
    public static void <#= Data.MethodCodeName #>(this IServiceCollection services)
    {
<#
        if (Data.Dependencies.Any(d => d.Interfaces.Length > 1))
        {
#>
        Func<IServiceProvider,object> factory;
<#
        }

        foreach (var dependency in Data.Dependencies.OrderBy(v => v.InstanceClassName))
        {
#>

<#
            var lifetime = dependency.Lifetime.ToServiceLifetime();
            if (dependency.Interfaces.Length == 1 && !dependency.ItselfRegistration)
            {
#>
        services.Add(new ServiceDescriptor(typeof(<#= dependency.Interfaces[0] #>), typeof(<#= dependency.InstanceClassName #>), <#= lifetime #>));
<#
            }
            else
            {
                if (dependency.CustomFactoryMethod is not null && !string.IsNullOrEmpty(dependency.CustomFactoryMethod))
                {
#>
        services.Add(new ServiceDescriptor(typeof(<#= dependency.InstanceClassName #>), <#= dependency.CustomFactoryMethod #>, <#= lifetime #>));
<#
                }
                else
                {
#>
        services.Add(new ServiceDescriptor(typeof(<#= dependency.InstanceClassName #>), typeof(<#= dependency.InstanceClassName #>), <#= lifetime #>));
<#
                }

                if (dependency.Interfaces.Length == 1)
                {
#>
        services.Add(new ServiceDescriptor(typeof(<#= dependency.Interfaces[0] #>), static p => p.GetRequiredService<<#= dependency.InstanceClassName #>>(), <#= lifetime #>));
<#
                }
                else if (dependency.Interfaces.Length > 1)
                {
#>
        factory = static p => p.GetRequiredService<<#= dependency.InstanceClassName #>>();
<#
                    foreach (var iface in dependency.Interfaces)
                    {
#>
        services.Add(new ServiceDescriptor(typeof(<#= iface #>), factory, <#= lifetime #>));
<#
                    }
                }
            }
        }

        if (Data.CustomDependenciesEnabled)
        {
#>

        AddCustomDependencies(services);
<#
        }
#>
    }
<#
        if (Data.CustomDependenciesEnabled)
        {
#>
    /// <summary>
    /// Custom dependencies registration.
    /// </summary>
    private static partial void AddCustomDependencies(IServiceCollection services);
<#
        }

        foreach (var dependencyWithFactoryMethod in Data.Dependencies.Where(d => !string.IsNullOrEmpty(d.CustomFactoryMethod)))
        {
#>
    /// <summary>
    /// Custom factory method for <see cref="<#= dependencyWithFactoryMethod.InstanceClassName #>"/>. 
    /// </summary>
    private static partial <#= dependencyWithFactoryMethod.InstanceClassName #> <#= dependencyWithFactoryMethod.CustomFactoryMethod! #>(IServiceProvider provider);
<#
        }
#>

}
<#
        foreach (var factory in Data.Factories.OrderBy(v => v.FactoryClassName))
        {
            var crefClassName = factory.InstanceClassDefinition.Replace("<", "{").Replace(">", "}");
            if (factory.GeneratingInterface is {} generatingInterface)
            {
#>

/// <summary>
/// Factory contract for <see cref="<#= crefClassName #>"/>.
/// </summary>
public interface <#= generatingInterface.Name #>
{
<#
                foreach (var method in generatingInterface.Methods)
                {
                    if (!method.HasTypeParameterConstraints(false))
                    {
#>
    <#= method.ReturnTypeName #> <#= method.Name #>(<#= method.GetParametersForSignature(true) #>);
<#
                    }
                    else
                    {
#>
    <#= method.ReturnTypeName #> <#= method.Name #>(<#= method.GetParametersForSignature(true) #>)
<#
                        foreach (var clause in method.GetTypeParameterClauses(false))
                        {
#>
        <#= clause #>
<#
                        }
#>
    ;
<#
                    }
                }
#>
}
<#
            }
#>

/// <summary>
/// Factory implementation for <see cref="<#= crefClassName #>"/>.
/// </summary>
internal sealed class <#= factory.FactoryClassName #> : <#= string.Join(", ", factory.GetInterfaces().Select(i => i.Name)) #>
{
    private readonly IServiceProvider _provider;

    public <#= factory.FactoryClassName #>(IServiceProvider provider)
    {
        _provider = provider;        
    }

<#
            foreach (var iface in factory.GetInterfaces())
            {
                foreach (var method in iface.Methods)
                {
#>
    <#= method.ReturnTypeName #> <#= iface.Name #>.<#= method.Name #>(<#= method.GetParametersForSignature(false) #>) 
 <#
                    foreach (var clause in method.GetTypeParameterClauses(true))
                    {
#>
        <#= clause #>
<#
                    }
                    var ctor = method.GetEquivalentConstructorMethod(factory.Constructors, iface.CastParameters);
                    if (ctor is null || ctor.Value.IsEmpty)
                    {
                        if (iface.AllowNotSupportedMethods)
                        {
#>
        => throw new System.NotSupportedException();
<#
                        }
                        else
                        {
#>
#error ResolveFactory: Can't find equivalent construtor for interface's method.
<#
                        }
                        continue;
                    }
#>
        => new <#= factory.InstanceClassDefinition #>(<#= ctor.Value.GetCallCtorParameters("_provider", method) #>);
<#
                }
            }
#>
}
<#
        }
    }
#>