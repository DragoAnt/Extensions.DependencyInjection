<#@ template language="C#" linePragmas="false" inherits="BaseTransformation<GenerationData>" visibility="internal" #>
// This file generated by DragoAnt.Extensions.DependencyInjection.Factory source generator

#nullable enable
<#
    foreach (var usingNs in Data
        .GetUsings("Microsoft.Extensions.DependencyInjection")
        .Except([Data.Namespace]))
    {
#>
using <#= usingNs #>;
<#
    }

    if (Data.Factories.Any(f => f.IsInvalid))
    {
        foreach (var invalidFactory in Data.Factories.Where(f => f.IsInvalid))
        {
#>
#error <#= invalidFactory.GetError() #>>
<#
        }
    }
    else
    {
#>

namespace <#= Data.Namespace #>;

/// <summary>
/// Factory dependency injection registration extensions.
/// </summary>
public static class <#= Data.MethodCodeName #>RegistrationExtensions
{
    /// <summary>
    /// <#= Data.MethodCodeName #> factories registration extensions.
    /// </summary>
    public static void Add<#= Data.MethodCodeName #>Factories(this IServiceCollection services)
    {
<#
        foreach (var factory in Data.Factories.OrderBy(v => v.FactoryClassName))
        {
            var addService = $"services.Add{factory.Lifetime}";
            var interfaces = factory.GetInterfaces().ToArray();
            if (interfaces.Length > 1)
            {
#>
        <#= addService #><<#= factory.FactoryClassName #>>();
<#
                foreach (var iface in interfaces)
                {
#>
        <#= addService #><<#= iface.Name #>>(p => p.GetRequiredService<<#= factory.FactoryClassName #>>());
<#
                }
            }
            else
            {
#>
        <#= addService #><<#= interfaces[0].Name #>, <#= factory.FactoryClassName #>>();
<#
            }
        }
#>
    }
}
<#
        foreach (var factory in Data.Factories.OrderBy(v => v.FactoryClassName))
        {
            if (factory.GeneratingInterface is {} generatingInterface)
            {
#>

/// <summary>
/// Factory contract for <see cref="<#= factory.InstanceClassName #>"/>.
/// </summary>
public interface <#= generatingInterface.Name #>
{
<#
                foreach (var method in generatingInterface.Methods)
                {
#>
    <#= factory.InstanceClassName #> Create(<#= method.GetParametersForSignature(true) #>);
<#
                }
#>
}
<#
            }
#>

<#= factory.GetError() #>
/// <summary>
/// Factory implementation for <see cref="<#= factory.InstanceClassName #>"/>.
/// </summary>
internal sealed class <#= factory.FactoryClassName #> : <#= string.Join(", ", factory.GetInterfaces().Select(i => i.Name)) #>
{
    private readonly IServiceProvider _provider;

    public <#= factory.FactoryClassName #>(IServiceProvider provider)
    {
        _provider = provider;        
    }

<#
            foreach (var iface in factory.GetInterfaces())
            {
                foreach (var method in iface.Methods)
                {
#>
    <#= method.ReturnTypeName #> <#= iface.Name #>.<#= method.Name #>(<#= method.GetParametersForSignature(false) #>) =>
<#
                    var ctor = method.GetEquivalentConstructorMethod(factory.Constructors, iface.CastParameters);
                    if (ctor is null)
                    {
                        if (iface.AllowNotSupportedMethods)
                        {
#>
        throw new System.NotSupportedException();
<#
                        }
                        else
                        {
#>
#error ResolveFactory: Can't find equivalent construtor for interface's method.
<#
                        }
                        continue;
                    }
#>
        new <#= factory.InstanceClassName #>(<#= ctor.Value.GetCallCtorParameters("_provider", method) #>);
<#
                }
            }
#>
}
<#
        }
    }
#>